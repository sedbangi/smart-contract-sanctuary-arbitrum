// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {IGelatoRelay1Balance} from "./interfaces/IGelatoRelay1Balance.sol";
import {IGelato1Balance} from "./interfaces/IGelato1Balance.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";
import {SponsoredCall} from "./types/CallTypes.sol";

/// @title  Gelato Relay contract
/// @notice This contract deals with synchronous payments and Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-states-count
contract GelatoRelay1Balance is IGelatoRelay1Balance, IGelato1Balance {
    using GelatoCallUtils for address;

    address public immutable gelato;

    modifier onlyGelato() {
        require(msg.sender == gelato, "Only callable by gelato");
        _;
    }

    constructor(address _gelato) {
        gelato = _gelato;
    }

    /// @notice Relay call + One Balance payment - with sponsor authentication
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @param _call Relay call data packed into SponsoredCall struct
    /// @notice Oracle value for exchange rate between native tokens and fee token
    /// @param  _nativeToFeeTokenXRateNumerator Exchange rate numerator
    /// @param  _nativeToFeeTokenXRateDenominator Exchange rate denominator
    /// @param _correlationId Unique task identifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function sponsoredCall(
        SponsoredCall calldata _call,
        address _sponsor,
        address _feeToken,
        uint256 _oneBalanceChainId,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _correlationId
    ) external onlyGelato {
        // CHECKS
        require(
            _call.chainId == block.chainid,
            "GelatoRelay.sponsoredCall:chainid"
        );

        // INTERACTIONS
        _call.target.revertingContractCall(
            _call.data,
            "GelatoRelay.sponsoredCall:"
        );

        emit LogUseGelato1Balance(
            _sponsor,
            _call.target,
            _feeToken,
            _oneBalanceChainId,
            _nativeToFeeTokenXRateNumerator,
            _nativeToFeeTokenXRateDenominator,
            _correlationId
        );
    }

    /// @notice Relay call + One Balance payment - with sponsor authentication
    /// @dev    This method can be called directly without passing through the diamond
    /// @dev    The validity of the emitted LogUseGelato1BalanceV2 event must be verified off-chain
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @param _target Relay call target
    /// @param _data Relay call data
    /// @param _correlationId Unique task identifier generated by gelato
    /// Signature is split into `r` and `vs` - See https://eips.ethereum.org/EIPS/eip-2098
    /// @param _r Checker signature
    /// @param _vs Checker signature
    function sponsoredCallV2(
        address _target,
        bytes calldata _data,
        bytes32 _correlationId,
        bytes32 _r,
        bytes32 _vs
    ) external {
        // These parameters are decoded from calldata
        (_correlationId);
        (_r);
        (_vs);

        // INTERACTIONS
        _target.revertingContractCall(_data, "GelatoRelay.sponsoredCallV2:");

        emit LogUseGelato1BalanceV2();
    }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

interface IGelato1Balance {
    event LogUseGelato1Balance(
        address indexed sponsor,
        address indexed target,
        address indexed feeToken,
        uint256 oneBalanceChainId,
        uint256 nativeToFeeTokenXRateNumerator,
        uint256 nativeToFeeTokenXRateDenominator,
        bytes32 correlationId
    );

    event LogUseGelato1BalanceV2();
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {SponsoredCall} from "../types/CallTypes.sol";

interface IGelatoRelay1Balance {
    function sponsoredCall(
        SponsoredCall calldata _call,
        address _sponsor,
        address _feeToken,
        uint256 _oneBalanceChainId,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _correlationId
    ) external;

    function gelato() external view returns (address);
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

library GelatoBytes {
    function calldataSliceSelector(
        bytes calldata _bytes
    ) internal pure returns (bytes4 selector) {
        selector =
            _bytes[0] |
            (bytes4(_bytes[1]) >> 8) |
            (bytes4(_bytes[2]) >> 16) |
            (bytes4(_bytes[3]) >> 24);
    }

    function memorySliceSelector(
        bytes memory _bytes
    ) internal pure returns (bytes4 selector) {
        selector =
            _bytes[0] |
            (bytes4(_bytes[1]) >> 8) |
            (bytes4(_bytes[2]) >> 16) |
            (bytes4(_bytes[3]) >> 24);
    }

    function revertWithError(
        bytes memory _bytes,
        string memory _tracingInfo
    ) internal pure {
        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err
        if (_bytes.length % 32 == 4) {
            bytes4 selector;
            assembly {
                selector := mload(add(0x20, _bytes))
            }
            if (selector == 0x08c379a0) {
                // Function selector for Error(string)
                assembly {
                    _bytes := add(_bytes, 68)
                }
                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));
            } else {
                revert(
                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"))
                );
            }
        } else {
            revert(
                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"))
            );
        }
    }

    function returnError(
        bytes memory _bytes,
        string memory _tracingInfo
    ) internal pure returns (string memory) {
        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err
        if (_bytes.length % 32 == 4) {
            bytes4 selector;
            assembly {
                selector := mload(add(0x20, _bytes))
            }
            if (selector == 0x08c379a0) {
                // Function selector for Error(string)
                assembly {
                    _bytes := add(_bytes, 68)
                }
                return string(abi.encodePacked(_tracingInfo, string(_bytes)));
            } else {
                return
                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"));
            }
        } else {
            return
                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"));
        }
    }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {GelatoBytes} from "./GelatoBytes.sol";

library GelatoCallUtils {
    using GelatoBytes for bytes;

    function revertingContractCall(
        address _contract,
        bytes memory _data,
        string memory _errorMsg
    ) internal returns (bytes memory returndata) {
        bool success;
        (success, returndata) = _contract.call(_data);

        // solhint-disable-next-line max-line-length
        // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L177
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(
                    isContract(_contract),
                    string(abi.encodePacked(_errorMsg, "Call to non contract"))
                );
            }
        } else {
            returndata.revertWithError(_errorMsg);
        }
    }

    // solhint-disable-next-line max-line-length
    // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L36
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

// Sponsored relay call
struct SponsoredCall {
    uint256 chainId;
    address target;
    bytes data;
}

// Relay call with user signature verification for ERC 2771 compliance
struct CallWithERC2771 {
    uint256 chainId;
    address target;
    bytes data;
    address user;
    uint256 userNonce;
    uint256 userDeadline;
}

// Concurrent relay call with user signature verification for ERC 2771 compliance
struct CallWithConcurrentERC2771 {
    uint256 chainId;
    address target;
    bytes data;
    address user;
    bytes32 userSalt;
    uint256 userDeadline;
}

struct RelayContext {
    address feeToken;
    uint256 fee;
}
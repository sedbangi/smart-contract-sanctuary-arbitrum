// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.25;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ISolidlyRouter01} from "./interfaces/swaps/ISolidlyRouter01.sol";
import {IUpgradeSource} from "./interfaces/IUpgradeSource.sol";
import {IMultiFeeDistribution} from "./interfaces/IMultiFeeDistribution.sol";
import {GovernableInit} from "./lib/GovernableInit.sol";
import {MinterStorage} from "./MinterStorage.sol";

/// @title Limestone Minter
/// @author Chainvisions
/// @notice Minter contract for the Limestone token.

contract Minter is IUpgradeSource, Initializable, GovernableInit {
    using MinterStorage for MinterStorage.Layout;

    /// @notice WETH token contract.
    IERC20 public immutable WETH;

    /// @notice Legacy router contract.
    ISolidlyRouter01 public immutable LEGACY_ROUTER;

    /// @notice Constructor for the minter contract.
    /// @param _weth WETH contract.
    /// @param _legacyRouter Legacy router contract (for Ramses).
    constructor(
        IERC20 _weth, 
        ISolidlyRouter01 _legacyRouter
    ) {
        WETH = _weth;
        LEGACY_ROUTER = _legacyRouter;
    }

    /// @notice Initializes the minter contract.
    /// @param _store Limestone storage contract for access control.
    /// @param _treasury Limestone treasury address.
    /// @param _lPerEth Amount of L3 tokens to mint per 1 ETH profit initially.
    function initialize(
        address _store,
        address _treasury,
        uint256 _lPerEth
    ) external initializer {
        __Governable_init_(_store);
        MinterStorage.layout().treasury = _treasury;
        MinterStorage.layout().limestonePerEth = _lPerEth;
    }

    /// @notice Collects a token and swaps it to WETH for the treasury.
    /// @param _token Token to collect.
    /// @param _amount Amount of tokens to collect.
    /// @return The amount of LIME points to mint from the fees.
    function notifyAndSwapToken(
        address _token,
        uint256 _amount
    ) external returns (uint256) {
        // Receive tokens.
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);

        // Perform swap.
        IERC20(_token).approve(address(LEGACY_ROUTER), 0);
        IERC20(_token).approve(address(LEGACY_ROUTER), _amount);
        uint256[] memory amounts = LEGACY_ROUTER.swapExactTokensForTokensSimple(_amount, 0, _token, address(WETH), false, address(this), block.timestamp + 600);

        // Notify to the treasury and calculate mint amount.
        uint256 wethAmount = amounts[amounts.length - 1];
        WETH.transfer(MinterStorage.layout().treasury, wethAmount);

        return wethAmount * _limePerEth();
    }

    /// @notice Collects and distributes protocol fees generated by strategies.
    /// @param _amount Amount of WETH to send to the minter.
    /// @return Amount of L3 tokens to distribute in return.
    function notifyProtocolFees(uint256 _amount) external returns (uint256) {
        // Collect WETH.
        WETH.transferFrom(msg.sender, address(this), _amount);

        // Send WETH to treasury.
        WETH.transfer(MinterStorage.layout().treasury, _amount);

        // Calculate L3 rewards that the strategy should distribute to vault.
        return _amount *_limePerEth();
    }

    /// @notice Sets the address for Limestone's treasury.
    /// @param _newTreasury New address for the treasury.
    function setTreasury(
        address _newTreasury
    ) external onlyGovernance {
        MinterStorage.layout().treasury = _newTreasury;
    }

    /// @notice Schedules a new contract upgrade.
    /// @param _newImpl New implementation contract.
    function scheduleUpgrade(
        address _newImpl
    ) external onlyGovernance {
        MinterStorage.layout().newImplementation = _newImpl;
    }

    /// @notice Finalizes an upgrade on the contract.
    function finalizeUpgrade() external override onlyGovernance {
        MinterStorage.layout().newImplementation = address(0);
    }

    /// @notice Whether or not the contract can be upgraded.
    /// @return If the contract can be upgraded.
    /// @return New implementation to upgrade to.
    function shouldUpgrade() external view override returns (
        bool,
        address
    ) {
        address newImpl = MinterStorage.layout().newImplementation;
        return (newImpl != address(0), newImpl);
    }

    /// @notice Calculates the true L3 emissions rate per 1 ETH.
    /// @return How many L3 tokens emitted per ETH (adjusted based on the actual and not stored amount).
    function limestonePerEth() external view returns (uint256) {
        return _limePerEth();
    }

    /// @notice Address of the Limestone treasury.
    function treasury() external view returns (address) {
        return MinterStorage.layout().treasury;
    }

    function _limePerEth() internal view returns (uint256) {
        return MinterStorage.layout().limestonePerEth;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Modifier to protect an initializer function from being invoked twice.
     */
    modifier initializer() {
        require(_initializing || !_initialized, "Initializable: contract is already initialized");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface ISolidlyRouter01 {
    // A standard Solidly route used for routing through pairs.
    struct Route {
        address from;
        address to;
        bool stable;
    }

    // Adds liquidity to a pair on Solidly
    function addLiquidity(address tokenA, address tokenB, bool stable, uint256 amountA, uint256 amountB, uint256 aMin, uint256 bMin, address to, uint256 deadline) external;
    // Swaps tokens on Solidly via a specific route.
    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, Route[] memory routes, address to, uint256 deadline) external returns (uint256[] memory);
    // Swaps tokens on Solidly from A to B through only one pair.
    function swapExactTokensForTokensSimple(uint256 amountIn, uint256 amountOutMin, address tokenFrom, address tokenTo, bool stable, address to, uint256 deadline) external returns (uint256[] memory);
}

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface IUpgradeSource {
  function finalizeUpgrade() external;
  function shouldUpgrade() external view returns (bool, address);
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

interface IMultiFeeDistribution {
    function notifyRewardAmount(address, uint256) external;
    function mint(address, uint256) external;
}

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {Storage} from "../Storage.sol";

/**
 * @dev Contract for access control where the governance address specified
 * in the Storage contract can be granted access to specific functions
 * on a contract that inherits this contract.
 *
 * The difference between GovernableInit and Governable is that GovernableInit supports proxy
 * smart contracts.
 */

contract GovernableInit is Initializable {

    bytes32 internal constant STORAGE_SLOT =
        keccak256('limestone.contracts.storage.lib.Governable');

  modifier onlyGovernance() {
    require(Storage(_storage()).isGovernance(msg.sender), "Governable: Not governance");
    _;
  }

  function __Governable_init_(address _store) public initializer {
    _setStorage(_store);
  }

  function _setStorage(address newStorage) private {
    bytes32 slot = STORAGE_SLOT;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      sstore(slot, newStorage)
    }
  }

  function setStorage(address _store) public onlyGovernance {
    require(_store != address(0), "Governable: New storage shouldn't be empty");
    _setStorage(_store);
  }

  function _storage() internal view returns (address str) {
    bytes32 slot = STORAGE_SLOT;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      str := sload(slot)
    }
  }

  function governance() public view returns (address) {
    return Storage(_storage()).governance();
  }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.25;

import {ISolidlyRouter01} from "./interfaces/swaps/ISolidlyRouter01.sol";

/// @title Limestone Minter Storage
/// @author Chainvisions
/// @notice Diamond storage contract for the Limestone minter contract.

library MinterStorage {

    struct Layout {
        /// @notice New contract implementation for upgrades.
        address newImplementation;

        /// @notice Limestone treasury address.
        address treasury;

        /// @notice Amount of LIME tokens minted per ETH profit.
        uint256 limestonePerEth;

        /// @notice Route for swapping a token (Ramses legacy).
        mapping(address => mapping(address => ISolidlyRouter01.Route)) tokenSwapRouteLegacy;
    }

    function layout() internal pure returns (Layout storage l) {
        assembly {
            // We hardcode this slot to use less bytecode
            // and save a small amount of gas not needing an MSTORE.
            l.slot := 0xe0a9da2ca95bcae9f3584f69a53b0fe07ff2cf27adde259930798573a2f6432d // TODO: Fix this shit
        }
    }

    
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Storage {

  address public governance;
  address public controller;

  constructor() {
    governance = msg.sender;
  }

  modifier onlyGovernance() {
    require(isGovernance(msg.sender), "Storage: Not governance");
    _;
  }

  function setGovernance(address _governance) public onlyGovernance {
    require(_governance != address(0), "Storage: New governance shouldn't be empty");
    governance = _governance;
  }

  function setController(address _controller) public onlyGovernance {
    require(_controller != address(0), "Storage: New controller shouldn't be empty");
    controller = _controller;
  }

  function isGovernance(address account) public view returns (bool) {
    return account == governance;
  }

  function isController(address account) public view returns (bool) {
    return account == controller;
  }
}